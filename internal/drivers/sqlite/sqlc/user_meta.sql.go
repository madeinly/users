// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_meta.sql

package sqlc

import (
	"context"
)

const addUserMeta = `-- name: AddUserMeta :one
INSERT INTO users_meta (
    user_id,
    meta_key,
    meta_value
) VALUES (
    ?, ?, ?
)
ON CONFLICT (user_id, meta_key) 
DO UPDATE SET meta_value = EXCLUDED.meta_value
RETURNING user_id, meta_key, meta_value
`

type AddUserMetaParams struct {
	UserID    string `json:"user_id"`
	MetaKey   string `json:"meta_key"`
	MetaValue string `json:"meta_value"`
}

func (q *Queries) AddUserMeta(ctx context.Context, arg AddUserMetaParams) (UsersMetum, error) {
	row := q.queryRow(ctx, q.addUserMetaStmt, addUserMeta, arg.UserID, arg.MetaKey, arg.MetaValue)
	var i UsersMetum
	err := row.Scan(&i.UserID, &i.MetaKey, &i.MetaValue)
	return i, err
}

const deleteMetas = `-- name: DeleteMetas :exec
DELETE FROM users_meta
WHERE user_id = ?
`

func (q *Queries) DeleteMetas(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.deleteMetasStmt, deleteMetas, userID)
	return err
}

const updateUserMeta = `-- name: UpdateUserMeta :one
UPDATE users_meta
SET meta_value = ?
WHERE user_id = ?
RETURNING user_id, meta_key, meta_value
`

type UpdateUserMetaParams struct {
	MetaValue string `json:"meta_value"`
	UserID    string `json:"user_id"`
}

func (q *Queries) UpdateUserMeta(ctx context.Context, arg UpdateUserMetaParams) (UsersMetum, error) {
	row := q.queryRow(ctx, q.updateUserMetaStmt, updateUserMeta, arg.MetaValue, arg.UserID)
	var i UsersMetum
	err := row.Scan(&i.UserID, &i.MetaKey, &i.MetaValue)
	return i, err
}
